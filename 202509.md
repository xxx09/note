# 20250901
- 1. mirax3报错 PhysX error: PxGpuDynamicsMemoryConfig::collisionStackSize buffer overflow detected, please increase its size to at least 68748736 in the scene desc! Contacts have been dropped.
, FILE /builds/omniverse/physics/physx/source/gpunarrowphase/src/PxgNarrowphaseCore.cpp, LINE 1606
环境数在12288时不报，到16384时才报错； 如果usd换为mirax_1.usd也不报错；
再次用python scripts/tools/convert_urdf.py转换mirax_1.usd,碰撞体个数更多，也没问题；
可以在base_env.py中l40设置 gpu_max_rigid_contact_count = 2**23, 设置多了会报错，同样有错误
是不是某些设置问题？
脚底由9个球碰撞体改为mesh，问题解决；

脚底板用9个碰撞点的mesh，上大的斜坡有问题；

- 2. pbhc代码跟踪
# 20250902
- 1. pbhc代码跟踪；
 - - reset_dof, default_dof*(0.5,1.5)
 - - obs: [action, base_ang_vel, dof_pos..., action[1:5], base_ang_vel[1:5], pro_g[1:5], ref_motion_phase[1:5], pro_g, ref_motion_phase]; 顺序相对而言较奇怪；history的历史为左进右出；
 todo: 修改obs的顺序，按照一帧一帧来进行处理； 需要修改motion_tracking.py中get_obs_history_actor处理；
- 2. sim2mujoco,排查到最后的问题为xml中关节角的顺序问题；ankle_pitch和ankle_roll的位置反了；
motion_track中提取得到
pos tensor([[ 2.2656e-02,  5.5728e-03,  4.3494e-01,  1.8852e-02, -7.5553e-02,
         -1.1068e-01, -2.3431e-02, -9.6452e-03, -1.1412e-01,  3.9374e-03,
          2.8423e-02, -6.2251e-02, -3.5684e-02, -8.7895e-02, -2.0566e-01,
          7.9600e-02,  3.8843e-01, -3.1820e-03,  1.6208e-01, -5.1819e-03,
         -1.4782e-01,  5.7071e-03,  3.2267e-01,  1.8227e-04,  1.4024e-01]],
       device='cuda:0')
vel       tensor([[ 0.0279,  0.0351,  0.1631,  0.0570, -0.1727, -0.0212,  0.0313, -0.0081,
         -0.0246,  0.0217, -0.0407, -0.0297,  0.0129, -0.0669,  0.0481,  0.0203,
         -0.0198, -0.0032,  0.0023, -0.0470, -0.0180, -0.0688, -0.0007,  0.0069,
         -0.0136]], device='cuda:0')

root_state    tensor([[ 0.2841,  0.0354,  0.7933, -0.0043,  0.0046,  0.7142,  0.6999,  0.0151,
          0.0028,  0.0020,  0.0395,  0.0154, -0.0450]], device='cuda:0')

# 20250903
- 1. dof_axis:
array([[ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.],
       [ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.],
       [ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.],waist
       [ 0.,  1.,  0.],
       [-1.,  0.,  0.],
       [ 0.,  0., -1.],
       [-1.,  0.,  0.],
       [ 0.,  0., -1.],
       [-1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.],
       [ 1.,  0.,  0.]], dtype=float32)

- 2. smpl_pose_moidfier, how to define it; 使用相对位姿； T_global_smpl;

#20250904
- 1. fit smpl, mink;  mink使用时，需要下载人体模型；
- 2. pose_aa为关节角相对上一个关节角的相对轴角；
- 3. vscode 无法跳转到定义，在.vscode中添加setting.json，添加以下内容【库的安装路径】：
```
"python.analysis.extraPaths": [
    "/home/xxx/workspace/minkowski-engine"
]
```
- 4. 真机测试mirax3多地形，站立时还是有点晃；但整体的稳定性明显增强，对扰动的适应变好，走波浪变好；； todo:增大站立时的比例；
- 5. mirax3的base_link改为pelvis; mirax3的arm_joint有转为为0 0 -1的，后续需要修改一下；

#20250905
- 1. convert_fit_motion.py, l371, why 右乘 RPY(np.pi/2, 0, np.pi/2).inv() ???
- 2. mirax3, 右臂关节对应不上，进行了一定的修改；但不知道pose_aa是否正确，主要是dof_axis那个关节不知是否应该取反；
可以用25dof的验证一下；【要求硬件的同时将臂的axis改成一致，世界坐标系的方向；不要用负轴】


- 3. 起两个mirax3的全地形训练；使用正常脚底的mesh；

# 20250908
- 1. mirax3在sim中的效果整体不如mirax1， 修改一些mesh参数，将joints范围修改为对称的，鞋底mesh改为box，查看训练效果；
- 2. 增加一个奖励项，奖励机器人在站立时，关节速度为0；
- 3. pbhc, mirax3重新生成xml，即可；但pose_aa有问题，g1能完全对齐到手腕，但mirax3的末端对不齐，有较大偏差； 
- 转轴的问题：shoulder_yaw， 存在问题；
- [已解决，最终发现是elbow_joints的固定旋转轴的问题，实际link是绕x轴旋转，后续一定要将link的基坐标配置为和世界坐标系一致；同时axis_dof要有正负号；]
- 4. mirax3,有腿内撇的倾向，将ref轨迹的hip_roll进行处理；同时加入站立时的关节速度0的奖励项；

# 20250909
- 1. mirax3 内撇，ref有问题，写错了关节角，站立时关节速度为0作用较弱，可以增强； stand_still都改成<0.1;
- 效果还是不太好；修改站立时奖励为0的exp系数； 去除对base_link的质量随机；站立百分比改为0.15；关节角范围改为mirax1的范围；
改完之后上楼成功率高一些，是环境数的问题还是关节角范围的问题？？后续验证一下；

- 2. smpl是有脚趾关节的；导致可能不水平；
- 3. blender可以查看smpl数据；安装smpl插件；
https://genmotion.readthedocs.io/en/latest/tutorial/render/blender/AMASS.html

# 20250910
- 1. 强制将pose_aa设置为0， 可以看到smpl的坐标系为y朝上，x朝左，z朝前；
- 2. 训练pbhc，报维度不匹配的错误；
/home/xxx/workspace/pbhc/humanoidverse/utils/motion_lib/torch_humanoid_batch.py
l268
rotations_world = torch.cat(rotations_world, dim=2)
第29，30维度的rotation为空；
数据retarget的生成问题，需要增加pose_aa的维度；
- 3. 训练前跳l2的； 触发terminate； 
- 4. 训练侧跳l2的，训练能ok也能deploy到mujoco，但reward不高；eval_agent时似乎机器人参考轨迹有时不对；

# 20250911
- 1. 测试直接用mujoco的humanoid模型导入amass数据，发现不可行；不是想要的姿态，中间应该还进行了较多的转换
- 2. 使用pbhc中的fit_smpl_shape.py生成的g1的shape参数，与其提供的shape参数不同； 与asap中生成的也不一样
shape_new:  tensor([[  2.2165,   4.4628,  -1.3951,  -1.6076,   7.2645,  10.2852, -11.6154,
          -6.2394, -27.4260,  14.0546]])
scale:  tensor([0.6779], requires_grad=True)
pbhc shape_new:  tensor([[  1.1312,   3.4239,  -1.4523,   0.5628,   9.0394,   7.7351, -19.6192,
           0.9426, -26.1463,  14.7299]])
pbhc scale:  tensor([0.7606], requires_grad=True)
asap shape_new:  tensor([[  1.3732,   3.5299,  -0.2324,   0.2094,   9.8958,   4.8070, -20.0350,
           2.5789, -30.1172,  14.6733]])
asap scale:  tensor([0.7542], requires_grad=True)

- 3. convert_fit_motion.py amass原始数据为 trans[根轨迹的平移 Kx3], poses[相对上一个关节的旋转Kx24x3]，
通过smplx生成顶点K*6890和关节位置K*24*3； root_trans和第一个关节pelvis不是同一个点； 根据关节位置进行缩放，得到缩放后的相对位置；
smplx在进行计算时，会自动应用z轴朝上的世界坐标旋转？？

#  20250912
- 1. pbhc训练， base_init_state pos, rot, lin_vel, ang_vel 3,4,3,3;
mink生成的quat初始值为 0，0，0.7，-0.7；  需要在init_state中修改其数据； config/robot/mirax3/mirax3.yaml l91
- 2. 针对motion_lib导入数据较慢的问题，因为是相同的数据，因此使用复制的方式对load_motion_with_skeleton进行复制， motion_lib_base.py l276-l318; 
- 3. 针对cmu的太极数据，将数据进行了截取，因为最后一帧不稳定；但pbhc训练时，有问题，显示显存不够！！！怀疑是数据复制过多，非必要！！！后续需要修改；截取一半还是爆掉显存；config/robot/mirax3/mirax3.yaml l193中 数据改为WJX即可；
- 修改取ref_motion的概率；修改初始状态，初始quat；hybrid_init_reference_motion_prob； 环境数使用16384
运行报错【在产生了9k的模型之后】：
/home/xxx/software/pytorch/aten/src/ATen/native/cuda/IndexKernel.cu:92: operator(): block: [564,0,0], thread: [16,0,0] Assertion `-sizes[i] <= index && index < sizes[i] && "index out of bounds"` failed
File "/home/xxx/workspace/pbhc/humanoidverse/envs/motion_tracking/motion_tracking.py", line 644, in _reset_dofs_base_default
    self.simulator.dof_vel[env_ids] = 0.
RuntimeError: CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.

# 20250915
- 1. 肩部关节的碰撞体去掉，运行过程中经常碰到身体，会产生干涉；
运动的关节角是否要微调，使得机器人更稳定比如膝盖再下蹲一点；
mujoco部署时，渲染过慢的修改；
- 2. 模型切换，使用0.24，0.48的初始关节角度； 自动就会使用default_joints的值【ref_init可修改其他值】
- 3. 新的训练：
将手臂关节碰撞体改掉；缩小torso_link的碰撞体大小；
env/motion_traking.yaml中terminate_when_motion_far_threshold_min由0.3改为0.8
将数据从走路初始姿态到motion的第一帧，进行插值；膝关节可以进行一定的调整；脚踝处理，将约束放宽；
脚底使用整个脚底作为碰撞体【改完这个之后sim2sim在mujoco中不平衡， 16384的9k效果反而好一些】
放开rewards参数中的contact_mask;
level_down_threshold 改为400，平均 40s/0.01=4000步, 3000-3600步
关节角reward使用不同的系数； 踝关节和腕关节给的权重小；
torso_link的随机， torso_link的mass和位置随机化增大；
推机器人的随机力，降低间隔;
rewards/motion_tracking/main.yaml 设置level_down_threshold和up_threshold 3000-3600步

训练16384的模型； 如果环境数为24576，会load数据时自动killed；

#20250916
- 1. nvidia自动进行了驱动更新；
cat /proc/driver/nvidia/version
NVRM version: NVIDIA UNIX Open Kernel Module for x86_64  570.133.07  Release Build  (dvs-builder@U22-I3-G01-1-1)  Fri Mar 14 12:57:14 UTC 2025
GCC version:  gcc version 12.3.0 (Ubuntu 12.3.0-1ubuntu1~22.04.2)
nvidia-smi显示内容如下
Failed to initialize NVML: Driver/library version mismatch
NVML library version: 570.172

- 2. feet_air_time系数改为0； level_down_threshold 改为2000， level_up_threshold 改为3000；motion_threshold_min改回0.3；
- 3. legged_robot_base.py  penlty_feet_ori,惩罚脚底不平，可增加系数； 受力脚【离base更近】保持水平；
teleop_body_position_feet 可以增加 teleop_body_position_root，

- 4. 训练系数改为1.0，同时增加脚底触地时的rpy； 脚底用4个点来替代[mesh在mujoco中不稳定，脚底改为平板也不行，转为box好一点，参考asap和host改为4个点]； 3000、2000改为2000、1000；

- 5. 轨迹从0点开始拼接，手臂
注意维度问题；31dof

- 6. 机器人整体有点前倾，root_quat进行左乘四元素[-0.02, 0.0, 0.0, 1.0]；


- 7. 添加外力扰动
self.simulator.apply_rigid_body_force_at_pos_tensor(push_forces_3d, body_positions)
维度是 环境数*link数*3； 位置设置为link的位置；

- 6. 校验机器人形态，shape参数是否一致；phc重新生成一份；

# 20250917
- 1. 检验腿部与base之间的距离；新训练的模型在刚开始的时候，右脚着地效果不太好； 查看delta值应该是正常的，
- 2. 加入了torso_link外扰的效果要优于没加外扰力的效果；明显体现在初始阶段，没加外扰的晃动更大；
- 3. 地面增加曲面地形；
- 4. 数据重新制作，右乘以四元素[0.0, -0.03, 0.0, 1.0]，整体后仰一点； 外扰力加大一点，间隔稍短一些; 效果似乎更好一些；
- 5. 跟踪reward，每个奖励都有一个输出头；hydra用法；


# 20250918
- 1. 仔细逐帧对比分析真机和仿真中的差异；
真机容易位置运动不到位；抖动是有外力支持下为了恢复原位导致的【真机25s，有点别住了的意思】；真机两条腿之间的相对位置和仿真中差异有点大；
原始数据25s处，左腿抬起来了再落地；
真机34s抖动，
第43s发现，真机和仿真对比的话，手臂和腰完全没有运动到位；
画图，画出action，pos，real action和real pos的对比；

腰部的方向似乎反了；【如果没反，那说明跟不上】

- 2. 写数据分析的代码；

- 3. 真机还是有点不太稳；
新的训练：修改pid的参数；参照g1进行修改，尤其是手臂上的pid参数；
增加扰动，shoulder_roll_link, hip_roll_link, 
将整条轨迹延长；30fps改为20fps;
base_com改为+-0.1；

训练很慢，不知道什么原因；

# 20250919
- 1. 昨晚的训练效果不好；先改回20fps； 16384
todo: 外力扰动减少； num_envs增加； pid参数改回； base_com y方向+-0.1；
lafan数据处理；
- 2. 验证修改terrain是否对训练速度有影响； 
- 3. lafan1数据集下载报lfs的错误， 可以通过下载fork它的库的其他链接来下载； 可以到页面点击右上角的raw data下载
fallAndGetUp1_subject1 
1950-2075: 站立到躺倒，2075-2216： 从躺倒到站起来；
fallAndGetup2_subject2
350-580 仰身起来； 822-1030 俯身起立；1195-1370 仰身从左侧起来； 3646-3791 俯身趴下；
fallAndGetup2_subject3
800-1036 仰身起来

dance1_subject2 貌似是查尔斯舞


- 4. base_com y方向改为 0.05， 8192训一个；20fps, 扰动去除；相当于只改了pid和帧率；
外力修改；
训练不收敛；
extern_force改为50； 
- 5. 新的训练，发现了推力重置的一个bug，推力的间隔时间重置没有加入索引；会导致实际没有外力干扰；
8192一直不太好；
- 6. 新的训练，使用fp30，使用trimesh，使用force50，ori5，
老的数据; 训练没收敛，效果很差；

根据课程学习来调节外扰力？？

# 20250920
- 1. 将扰动力去除，查看训练效果；
- 2. 收敛慢；将地面改为plane；收敛变快； [ok]
尝试： plane + 扰动力; [ok]
尝试： plane + 扰动力 + 多地形[加入课程学习]； 训练慢，训练效果差；

地图课程学习：
terrain.yaml 改为True，只是根据难度进行地形的划分；

- 3. 训练很慢，环境中增加num_cols,会加快训练的速度；
max_init_terrain_level =0, 训练效果差；
flat = 1， 几乎全为平地； 训练也不收敛；
测试，平地将custom_origins改为True，查看训练效果；[没有什么影响]
训练多地形，增加reset时机器人落地时的高度+0.03【似乎reset时机器人一直直接落地】； 多地形全为flat时，训练时间还是很长？？？
但是多地形时，增加落地高度，机器人的训练能够起来；

测试，多地形增加rough，也似乎是ok的；说明主要问题在于机器人的原始数据！！！！！

总结：1. 增加num_cols, 2. 原始数据有问题，增加root的高度；

训练： cumstom_origins设置为了False；
16384 1，多地形； --效果不太好！后期训练时长久
2, 平地；  -- 训练
2，多地形扰动加大；数据使用fp20； 不要课程学习; 重置时加入各种随机，noise_to_initial_level 0.6，



base_task.py, l118 custom_origins=False, 




todo：
加入地图的课程学习；加入扰动力的课程学习；

无地形的训练，多加扰动；

有地形的训练，正常扰动；

# 20250922
- 1. lafan数据集查看
- 2. 真机测试效果，mesh地面真机效果要好很多；
- 2. 推力加入课程学习， reset时高度由0.03改为0.015； 防止谐波电机坏掉，手臂的pd改小；pd系数取的20比1；初始化加噪声；
训练的结果，最开始的时候一直晃晃悠悠的【前后晃动】，打起来了蹭着地面动，不稳！

- 2. GVHMR 生成八式太极视频，
GVHMR安装的问题
A cuda error，安装nightly版本的torch；
B pytorch3d的问题，git clone pytorch3d，本地pip install
C load模型错误，torch.load(weight_only=False)
D FileNotFoundError: [Errno 2] No such file or directory: 'ffmpeg'
sudo apt install ffmpeg

# 20250923
- 1. 脚踝的关节角跟踪放松为0.3； 【真机效果还好】
- 2. 使用gvhmr生成八式太极视频；整体偏差更大；
- 3. cmu_taichi数据，再重新捋一下；
重新制作一遍数据；

- 1. 脚踝的关节角跟踪放松为0.3； 训练16384个环境；

# 20250924
- 1. numpy2.1.2生成的pickle文件无法再numpy1.23.5中导入； 修改方法：
with open(args.save_path, "wb") as f:
            pickle.dump(motion_data, f, protocol=4)  # Use protocol 4 for better compatibility
- 2. 修改数据，使用抬脚的数据；
记录数据进行修改；主要使用knee关节角的修改；

先截取数据；插值数据，然后再修改；
1. 数据先修改
 站立-》200帧； 迈右腿；
dof整体数据可以做个平滑滤波；
650-710,左脚抬起来；
800帧左右，左脚要抬起来！！
1000帧，右脚要抬起来

2. 数据再截取

3. 数据头尾插值

3. 对原始插入的数据进行修改， 抬脚得到运动的初始姿态；

4. contact_mask计算

5. pose_aa重新计算

6. 处理330-370帧全身的抖动； root的位置、姿态平滑 + dof的平滑；

- 3. 新的数据训练
ref_joint_scale都改为1，
15k初始站立时不稳，机器人倒；
9k初始右倾斜，和仿真不太对；
2k时整体动作跟踪效果较差，但稳定性最好，能完成全套的动作；

todo：
后续看实际情况，可能要针对root的速度往复进行惩罚！
站立时前后晃动厉害，惩罚roll的速度；

5. 注意dof_axis带来的影响；

# 20250925
- 1. 训练的结果：没有很明显的抬脚动作； 
增大contact的奖励，body_feet权重增大，去除reset时的随机化；高度增量去除；
motion_tracking_link加上左右脚；【训练会报错，暂时去除；只是用来跟踪vr中3个点的，头和两个手】
增大扰动的间隔； 增大ref_joint_scale膝盖knee和hip_pitch的权重，
参考轨迹概率初始化为1；

新的训练，2k效果比之前差太多；

- 2. 回退到以前的参数，增加feet_air的奖励；增大knee和hip_pitch权重；
7k的测试，脚确实能抬起来；这样子整体稳定性有较大的提升；

设置motion_far的阈值；

- 2. 新的训练：
去除开始的90和末尾90帧；
修改机器人的手臂的初始关节角度；
高度提高5mm；
去除reset时各关节的随机化；
降低init_state的高度，0.79->0.765;

真机测一下2k的模型，看下效果；[2k勉勉强强能够稳定住]

- 3. 后续可以将外力干扰降低？ 
增大推力间隔，降低推力大小；
去掉reset时的噪音；
参考轨迹概率初始化为0.6；
1000-2000改为2000-3000；
增大ref_joint_scale中hip和knee的权重；
扩大motion_far的范围阈值；
return确实变高了，但整体稳定性变差了很多；

#20250926
- 1. 仿真中有明显的抬脚动作，但多次触地，导致真机测试及其不稳定；
- 2. 4096的环境训练，查看环境个数对最终性能的影响；

惩罚root link的roll和pitch的角速度； 惩罚触地与ref不同；
真机测试效果还行；

- 3. 制作taiji5的数据
sRot.as_euler
'xyz'为绕自己轴的旋转顺序；
"ZYX"为绕固定轴的旋转顺序； 'xyz'等效于"ZYX"；

- 4. 将扰动加回去； ref改回1，
16384， 
训练没训起来，大概率是并行数过多的原因；

#  20250928
-1. 训练v2的数据，使用8192个环境，注意时长为90s； 2700帧；
分析数据发现
A. ankle_roll的关节角度超过了机器人的限位；

penalty_root_roll_pitch_vel=-5 过大，导致机器人基本不动；
- 2. 抗冲击载荷，给的100N； 跟踪精度0.1rad；
- 3. 处理青海摇的数据；
- 4. 训练青海摇数据，需要处理init的pos和rot，
 尽量降低初始扰动
 数据长度变低，因此数据要改；
 2000-3000改为1000到1500

# 20250929
-1. 效果不太好
-2. 使用平地训练；4096个env，试试看；
修改观测值，将ref_joint输入到观测值中；

-训练v2，4096个env； 效果还可以，训练比较快，但仍旧触地有问题
- 3. 重新训练v2
将contact相关，ori相关的奖励惩罚都去掉，使用pbhc最原始的；【效果不好，触地效果很差】

观测顺序
['actions', 'base_ang_vel', 'dof_pos', 'dof_vel', 'history_actor', 'projected_gravity', 'ref_joint_pos', 'ref_motion_phase']
history_actor 由以下组成； 每种数据由history_num组成，即 action*history_num, base_ang_vel*history_num ...
['actions', 'base_ang_vel', 'dof_pos', 'dof_vel', 'projected_gravity', 'ref_joint_pos', 'ref_motion_phase']

- 4. 会议讨论：
脚底板橡胶去掉；脚踝pitch；
科技月展示：走路、跑步；
多地形；需要扶一下；【】
硬件准备4台，调试好几台机器；动作跟踪拖架子；多地形调一调；

脚底板水平的惩罚，改小了看起来不晃了；

Any2Track；思路挺新的，DWL；tracking 开源了，
pbhc去实现，单动作改动还不算多；adapter比较多；

ankle_roll把角度改小；mirax3.xml

- 5. ankle_roll把角度范围改小为0.32， 训练带触地reward的模型，不过系数改为以前的0.1倍；加入域泛化；推力扰动加大；参考轨迹2k-3k；
push_scale由当前ref_motion_len/3决定；


